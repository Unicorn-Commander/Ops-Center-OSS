"""
Granite Extraction API Keys Router
Manages API keys for the Granite extraction service.
"""

import os
import secrets
import hashlib
import subprocess
from datetime import datetime, timezone
from typing import Optional, List
from uuid import UUID

from fastapi import APIRouter, HTTPException, Depends, Request
from pydantic import BaseModel, Field
import asyncpg

router = APIRouter(prefix="/api/v1/granite-keys", tags=["Granite API Keys"])

# Database connection
DATABASE_URL = os.getenv("DATABASE_URL", "postgresql://unicorn:unicorn@unicorn-postgresql:5432/unicorn_db")

# Granite extraction service paths
EXTRACTION_ENV_PATH = "/home/deploy/models/extraction/.env"
EXTRACTION_COMPOSE_PATH = "/home/deploy/models/extraction/docker-compose.extraction.yml"


# --- Pydantic Models ---

class APIKeyCreate(BaseModel):
    name: str = Field(..., min_length=1, max_length=255)
    description: Optional[str] = None
    expires_days: Optional[int] = Field(None, ge=1, le=365)


class APIKeyResponse(BaseModel):
    id: UUID
    name: str
    description: Optional[str]
    api_key_prefix: str
    is_active: bool
    created_by: Optional[str]
    created_at: datetime
    last_used_at: Optional[datetime]
    expires_at: Optional[datetime]


class APIKeyCreatedResponse(APIKeyResponse):
    api_key: str  # Only returned on creation - show once!


class APIKeyUpdate(BaseModel):
    name: Optional[str] = None
    description: Optional[str] = None
    is_active: Optional[bool] = None


# --- Database helpers ---

async def get_db_pool():
    """Get database connection pool."""
    return await asyncpg.create_pool(DATABASE_URL, min_size=1, max_size=5)


def hash_api_key(api_key: str) -> str:
    """Hash an API key using SHA-256."""
    return hashlib.sha256(api_key.encode()).hexdigest()


def generate_api_key() -> tuple[str, str]:
    """Generate a new API key and return (full_key, prefix)."""
    key = secrets.token_urlsafe(32)
    prefix = key[:8] + "..."
    return key, prefix


async def sync_keys_to_extraction_service():
    """Sync active API keys to the Granite extraction service .env file."""
    try:
        pool = await get_db_pool()
        async with pool.acquire() as conn:
            rows = await conn.fetch("""
                SELECT api_key_hash FROM granite_api_keys
                WHERE is_active = true
                  AND (expires_at IS NULL OR expires_at > CURRENT_TIMESTAMP)
            """)
        await pool.close()

        if not rows:
            return False, "No active keys to sync"

        # We need to store the actual keys, not hashes, for the proxy
        # But we only have hashes in the DB for security
        # Solution: Store encrypted keys or use a key cache
        # For now, we'll skip sync if no plaintext keys available
        # The sync happens on key creation when we have the plaintext

        return True, f"Sync check completed, {len(rows)} active keys"

    except Exception as e:
        return False, str(e)


async def write_keys_to_env(keys: List[str]):
    """Write API keys to the extraction service .env file."""
    try:
        env_content = f"""# Granite Extraction Proxy Configuration
# Auto-generated by Ops-Center - DO NOT EDIT MANUALLY
# Last updated: {datetime.now(timezone.utc).isoformat()}

# API Keys for authenticating requests (comma-separated)
EXTRACTION_API_KEYS={','.join(keys)}

# Idle timeout in seconds (default: 900 = 15 minutes)
# GRANITE_IDLE_TIMEOUT=900
"""
        with open(EXTRACTION_ENV_PATH, 'w') as f:
            f.write(env_content)

        return True, "Keys written to .env"
    except Exception as e:
        return False, str(e)


async def restart_granite_proxy():
    """Restart the granite proxy to pick up new keys."""
    try:
        result = subprocess.run(
            ["docker", "restart", "unicorn-granite-proxy"],
            capture_output=True,
            text=True,
            timeout=30
        )
        if result.returncode == 0:
            return True, "Proxy restarted"
        else:
            return False, result.stderr
    except Exception as e:
        return False, str(e)


# --- Session/Auth helpers ---

async def get_current_user(request: Request) -> dict:
    """Get current user from session."""
    # Simplified - in production, validate session token
    session_token = request.cookies.get("session_token")
    if not session_token:
        raise HTTPException(status_code=401, detail="Not authenticated")

    # For now, return a basic user dict
    # In production, look up session in Redis and get user info
    return {"email": "admin@magicunicorn.tech", "role": "admin"}


# --- API Endpoints ---

@router.get("/", response_model=List[APIKeyResponse])
async def list_api_keys(request: Request):
    """List all Granite API keys."""
    await get_current_user(request)

    pool = await get_db_pool()
    try:
        async with pool.acquire() as conn:
            rows = await conn.fetch("""
                SELECT id, name, description, api_key_prefix, is_active,
                       created_by, created_at, last_used_at, expires_at
                FROM granite_api_keys
                ORDER BY created_at DESC
            """)

        return [dict(row) for row in rows]
    finally:
        await pool.close()


@router.post("/", response_model=APIKeyCreatedResponse)
async def create_api_key(key_data: APIKeyCreate, request: Request):
    """Create a new API key."""
    user = await get_current_user(request)

    # Generate the key
    api_key, prefix = generate_api_key()
    key_hash = hash_api_key(api_key)

    # Calculate expiry
    expires_at = None
    if key_data.expires_days:
        from datetime import timedelta
        expires_at = datetime.now(timezone.utc) + timedelta(days=key_data.expires_days)

    pool = await get_db_pool()
    try:
        async with pool.acquire() as conn:
            row = await conn.fetchrow("""
                INSERT INTO granite_api_keys (name, description, api_key_hash, api_key_prefix, created_by, expires_at)
                VALUES ($1, $2, $3, $4, $5, $6)
                RETURNING id, name, description, api_key_prefix, is_active, created_by, created_at, last_used_at, expires_at
            """, key_data.name, key_data.description, key_hash, prefix, user.get("email"), expires_at)

            # Get all active keys for sync
            all_keys = await conn.fetch("""
                SELECT api_key_hash FROM granite_api_keys
                WHERE is_active = true
                  AND (expires_at IS NULL OR expires_at > CURRENT_TIMESTAMP)
            """)

        # We need to sync the new key - but we need plaintext keys
        # For now, store the new key and update .env
        # Read existing keys from .env and append the new one
        existing_keys = []
        try:
            with open(EXTRACTION_ENV_PATH, 'r') as f:
                for line in f:
                    if line.startswith("EXTRACTION_API_KEYS="):
                        existing_keys = line.strip().split("=", 1)[1].split(",")
                        existing_keys = [k.strip() for k in existing_keys if k.strip()]
                        break
        except FileNotFoundError:
            pass

        # Add the new key
        existing_keys.append(api_key)

        # Write back
        await write_keys_to_env(existing_keys)

        # Restart proxy
        await restart_granite_proxy()

        result = dict(row)
        result["api_key"] = api_key  # Only returned on creation!

        return result
    finally:
        await pool.close()


@router.get("/{key_id}", response_model=APIKeyResponse)
async def get_api_key(key_id: UUID, request: Request):
    """Get a specific API key by ID."""
    await get_current_user(request)

    pool = await get_db_pool()
    try:
        async with pool.acquire() as conn:
            row = await conn.fetchrow("""
                SELECT id, name, description, api_key_prefix, is_active,
                       created_by, created_at, last_used_at, expires_at
                FROM granite_api_keys
                WHERE id = $1
            """, key_id)

        if not row:
            raise HTTPException(status_code=404, detail="API key not found")

        return dict(row)
    finally:
        await pool.close()


@router.put("/{key_id}", response_model=APIKeyResponse)
async def update_api_key(key_id: UUID, key_data: APIKeyUpdate, request: Request):
    """Update an API key."""
    await get_current_user(request)

    pool = await get_db_pool()
    try:
        async with pool.acquire() as conn:
            # Build dynamic update
            updates = []
            values = []
            param_count = 1

            if key_data.name is not None:
                updates.append(f"name = ${param_count}")
                values.append(key_data.name)
                param_count += 1

            if key_data.description is not None:
                updates.append(f"description = ${param_count}")
                values.append(key_data.description)
                param_count += 1

            if key_data.is_active is not None:
                updates.append(f"is_active = ${param_count}")
                values.append(key_data.is_active)
                param_count += 1

            if not updates:
                raise HTTPException(status_code=400, detail="No fields to update")

            values.append(key_id)
            query = f"""
                UPDATE granite_api_keys
                SET {', '.join(updates)}
                WHERE id = ${param_count}
                RETURNING id, name, description, api_key_prefix, is_active,
                          created_by, created_at, last_used_at, expires_at
            """

            row = await conn.fetchrow(query, *values)

        if not row:
            raise HTTPException(status_code=404, detail="API key not found")

        return dict(row)
    finally:
        await pool.close()


@router.delete("/{key_id}")
async def revoke_api_key(key_id: UUID, request: Request):
    """Revoke (deactivate) an API key."""
    await get_current_user(request)

    pool = await get_db_pool()
    try:
        async with pool.acquire() as conn:
            # Get the key prefix before deactivating
            row = await conn.fetchrow("""
                UPDATE granite_api_keys
                SET is_active = false
                WHERE id = $1
                RETURNING api_key_prefix
            """, key_id)

        if not row:
            raise HTTPException(status_code=404, detail="API key not found")

        # Note: We can't easily remove the key from .env since we don't have the plaintext
        # The key will still work until proxy restart with fresh keys
        # For production, implement proper key rotation

        return {"message": "API key revoked", "prefix": row["api_key_prefix"]}
    finally:
        await pool.close()


@router.post("/sync")
async def sync_keys(request: Request):
    """Manually trigger sync of keys to extraction service."""
    await get_current_user(request)

    # Restart the proxy to pick up current .env
    success, message = await restart_granite_proxy()

    return {
        "success": success,
        "message": message
    }


@router.get("/status/proxy")
async def get_proxy_status(request: Request):
    """Get the status of the Granite proxy."""
    await get_current_user(request)

    try:
        result = subprocess.run(
            ["docker", "inspect", "-f", "{{.State.Status}}", "unicorn-granite-proxy"],
            capture_output=True,
            text=True,
            timeout=10
        )
        status = result.stdout.strip() if result.returncode == 0 else "unknown"

        return {
            "proxy_status": status,
            "proxy_container": "unicorn-granite-proxy"
        }
    except Exception as e:
        return {
            "proxy_status": "error",
            "error": str(e)
        }
